#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

// Payload from Miss/Closest Hit
layout(location = 0) rayPayloadEXT vec3 hitValue;

// --- Set 0: Global Data ---
layout(set = 0, binding = 0, std140) uniform CameraBufferObject {
    mat4 projection;
    mat4 view;
    mat4 inverseProjection;
    mat4 inverseView;
} cam;

// --- Set 1: Ray Tracing Specific Data ---
layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 1, binding = 1, rgba16f) uniform image2D outputImage;

// G-Buffer Inputs
layout(set = 1, binding = 3) uniform sampler2D gbufferPosition;
layout(set = 1, binding = 4) uniform sampler2D gbufferNormal;
layout(set = 1, binding = 5) uniform sampler2D gbufferAlbedo;
layout(set = 1, binding = 6) uniform sampler2D gbufferProperties;

void main() {
    // Screen coordinates for G-Buffer lookup
    // *** FIXED: Use uvec2 for launch ID/Size ***
    uvec2 pixelCoords = gl_LaunchIDEXT.xy;
    uvec2 size        = gl_LaunchSizeEXT.xy;
    // *** FIXED: Explicit cast to vec2 for calculation ***
    vec2 texCoord     = (vec2(pixelCoords) + vec2(0.5)) / vec2(size);

    // Sample G-Buffer
    vec4 posSample    = texture(gbufferPosition, texCoord);

    // Simple check if the pixel hit anything in the G-Buffer pass
    if (posSample.a < 0.5) {
        imageStore(outputImage, ivec2(pixelCoords), vec4(0.0, 0.0, 0.0, 1.0)); // imageStore needs ivec2
        return;
    }

    // --- Ray Definition ---
    vec3 worldPos = posSample.xyz;
    vec3 rayOrigin = vec3(cam.inverseView[3]);
    vec3 rayDirection = normalize(worldPos - rayOrigin);

    // --- Ray Tracing ---
    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xFF;
    float tMin    = 0.01;
    float tMax    = 100.0;
    int missIndex = 0;

    traceRayEXT(topLevelAS,
                rayFlags,
                cullMask,
                0,          // SBT record offset for hit group
                0,          // SBT record stride
                missIndex,  // Miss index
                rayOrigin, tMin, rayDirection, tMax,
                0           // Payload location
    );

    // Write the result from the payload
    imageStore(outputImage, ivec2(pixelCoords), vec4(hitValue, 1.0)); // imageStore needs ivec2
}