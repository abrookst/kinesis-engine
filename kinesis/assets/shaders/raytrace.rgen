#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

// --- Payload Definition (Must match other shaders) ---
layout(location = 0) rayPayloadEXT HitPayload {
    vec3 hitColor;      // Emission/Light from the hit
    vec3 attenuation;   // Throughput color (albedo)
    vec3 nextRayOrigin; // Origin for next bounce
    vec3 nextRayDir;    // Direction for next bounce
    int done;           // 0 = continue, 1 = stop
    uint seed;          // Random seed
} payload;

// --- Camera Uniform ---
layout(set = 0, binding = 0, std140) uniform CameraBufferObject {
    mat4 projection;
    mat4 view;
    mat4 inverseProjection;
    mat4 inverseView;
    uint frameNumber;   // For temporal accumulation
    float time;         // Optional: for motion blur
} cam;

// --- Ray Tracing Bindings ---
layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 1, binding = 1, rgba16f) uniform image2D outputImage;
layout(set = 1, binding = 2, rgba16f) uniform image2D accumulationImage; // Temporal accumulation

// --- Random Number Generator (Improved) ---
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float rnd(inout uint state) {
    state = pcg_hash(state);
    return float(state) / float(0xFFFFFFFFu);
}

vec3 randomInUnitDisk(inout uint seed) {
    float r = sqrt(rnd(seed));
    float theta = 2.0 * 3.14159265359 * rnd(seed);
    return vec3(r * cos(theta), r * sin(theta), 0.0);
}

void main() {
    uvec2 pixelCoords = gl_LaunchIDEXT.xy;
    uvec2 size = gl_LaunchSizeEXT.xy;
    
    // --- Multi-Sample Anti-Aliasing ---
    int samplesPerPixel = 8; // Start with 4, increase to 8, 16, 32 for better quality
    vec3 accumulatedColor = vec3(0.0);
    
    for (int smp = 0; smp < samplesPerPixel; smp++) {

        uint seed = pcg_hash(pixelCoords.y * size.x + pixelCoords.x +  cam.frameNumber * 7919u + uint(smp) * 104729u);
        
        // --- Camera Ray with Jitter (Anti-Aliasing) ---
        vec2 jitter = vec2(rnd(seed), rnd(seed)) - 0.5;
        vec2 pixelCenter = vec2(pixelCoords) + 0.5 + jitter;
        vec2 inUV = pixelCenter / vec2(size);
        
        // Convert to clip space (-1 to 1) with correct Y direction
        vec2 clipCoords = inUV * 2.0 - 1.0;
        clipCoords.y = -clipCoords.y; // Correct for Vulkan's coordinate system
        
        // Create ray from camera
        vec4 target = cam.inverseProjection * vec4(clipCoords.x, clipCoords.y, 1.0, 1.0);
        vec3 rayDirection = normalize((cam.inverseView * vec4(normalize(target.xyz), 0.0)).xyz);
        vec3 rayOrigin = vec3(cam.inverseView[3]); // Camera position
        
        vec3 throughput = vec3(1.0);
        vec3 sampleColor = vec3(0.0);
        
        // --- Path Tracing Loop ---
        for (int depth = 0; depth < 5; depth++) {
            // Reset payload for this trace
            payload.done = 1;
            payload.hitColor = vec3(0.0);
            payload.attenuation = vec3(0.0);
            payload.seed = seed;
            
            // Trace the ray
            traceRayEXT(topLevelAS, 
                       gl_RayFlagsOpaqueEXT, 
                       0xFF,              // Cull mask
                       0, 0, 0,           // SBT offsets
                       rayOrigin, 
                       0.001,             // tMin
                       rayDirection, 
                       1000.0,            // tMax
                       0                  // Payload location
            );
            
            // Update seed from payload
            seed = payload.seed;
            
            // Accumulate emitted light
            sampleColor += throughput * payload.hitColor;
            
            // Stop if ray terminated or throughput is negligible
            if (payload.done == 1 || 
                max(throughput.r, max(throughput.g, throughput.b)) < 0.001) {
                break;
            }
            
            // Russian Roulette after 5 bounces
            if (depth > 5) {
                float p = max(throughput.r, max(throughput.g, throughput.b));
                if (rnd(seed) > p) {
                    break;
                }
                throughput /= p; // Compensate for survival
            }
            
            // Apply attenuation and continue
            throughput *= payload.attenuation;
            
            // Setup next bounce
            rayOrigin = payload.nextRayOrigin;
            rayDirection = payload.nextRayDir;
        }
        
        accumulatedColor += sampleColor;
    }
    
    // Average the samples
    accumulatedColor /= float(samplesPerPixel);
    
    // --- Temporal Accumulation (Optional but highly recommended) ---
    vec3 previousColor = vec3(0.0);
    if (cam.frameNumber > 0) {
        ivec2 storeCoords = ivec2(pixelCoords.x, int(size.y) - int(pixelCoords.y) - 1);
        previousColor = imageLoad(accumulationImage, storeCoords).rgb;
    }
    
    // Blend with previous frames (exponential moving average)
    float alpha = 0.1; // Blend factor: lower = more smoothing but slower to update
    vec3 finalColor;
    
    if (cam.frameNumber == 0) {
        finalColor = accumulatedColor;
    } else {
        finalColor = mix(previousColor, accumulatedColor, alpha);
    }
    
    // --- Store Results ---
    ivec2 storeCoords = ivec2(pixelCoords.x, int(size.y) - int(pixelCoords.y) - 1);
    imageStore(outputImage, storeCoords, vec4(finalColor, 1.0));
    
    // Store for next frame's accumulation
    if (cam.frameNumber > 0) {
        imageStore(accumulationImage, storeCoords, vec4(finalColor, 1.0));
    }
}